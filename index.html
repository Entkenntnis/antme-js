<!DOCTYPE HTML>
<html>
    <head>
        <meta charset="utf-8">
        <title>Loading Ant model!</title>
        <style>
            body { margin: 0}
            canvas { width:100%; height:100% }
        </style>
    </head>
    <body>
        <script src="js/THREE.js"></script>
        <script src="js/orbit.js"></script>
        <script src="js/tween.js"></script>
        <script src="js/stats.min.js"></script>
        <script>
"use strict";

// encapsulate our project
//(function(global){
  
  // project-wide variables
  var scene, camera, renderer, stats, controls, manager;
  
  function init(){
    // our stage
    scene = new THREE.Scene();
    
    // the floor lies in the xz-plane, don't worry about aspect here, will be done on resize 
    camera = new THREE.PerspectiveCamera(60, 1 /*aspect*/, 0.1, 10000);
    camera.position.set(0, 600, 1700);
    
    // the worker in the shadow
    renderer = new THREE.WebGLRenderer();
    document.body.appendChild(renderer.domElement);
    
    // showing nice fps
    stats = new Stats();
    stats.showPanel( 1 ); // 0: fps, 1: ms, 2: mb, 3+: custom
    document.body.appendChild( stats.dom );
    
    // make it movable
    controls = new THREE.OrbitControls(camera);
    controls.maxPolarAngle = Math.PI/2;
    controls.maxDistance = 2000;
    controls.clamper = function(pos){
      if (pos.y < 0.5) {pos.y = 0.5;} // should add clamper to protect skybox
    };
    
    // handle loading
    manager = new THREE.LoadingManager();
    
    // making it awesome fullwindow
    window.addEventListener('resize', resize, false);
    resize();
    
    vw.load();
    
    manager.onLoad = function(){
      vw.onLoad();
      SimPulse.init(); // currently simulation starts automatically
      animate()
    };
  }
  
  function resize() {
    var w = document.documentElement.clientWidth;
    var h = document.documentElement.clientHeight;
    renderer.setSize(w, h);
    camera.aspect = w/h;
    camera.updateProjectionMatrix();
  }

  function animate(e){
    if (SimPulse.needsRedraw){
      stats.begin();
      renderer.render(scene, camera);
      SimPulse.needRedraw = false;
      stats.end();
    }
    requestAnimationFrame(animate);
  }
  
  
  // THIS IS a 3d object manager
  function UnitStore(proto){
    var store = {};
    var ready = [];
    var prefix = 'unitstorekey:';
    
    this.has = function(id){
      return (prefix + id) in store;
    }
    this.get = function(id){
      if (this.has(id))
        return store[prefix + id];
      else {
        if (ready.length > 0) {
          var next = ready[0];
          next.visible = true;
          ready.splice(0, 1);
          store[prefix + id] = next;
          return next;
        } else {
          var newUnit = proto.clone();
          scene.add(newUnit);
          store[prefix+id] = newUnit;
          return newUnit;
        }
      }
    }
    this.remove = function(id){
      var obj = store[prefix + id];
      obj.visible = false;
      delete store[prefix + id];
      ready.push(obj);
    }
  }
  
  
  
  // START OF 3d view related stuff
  
  var vw = {
      ant0 : undefined
    , bug0 : undefined
    , hill0 : undefined
    , sugar0 : undefined
    , apple0 : undefined
    , gamefloor : undefined
    , skybox : undefined
    , antStore : undefined
    , hillStore : undefined
    , sugarStore : undefined
    , appleStore : undefined
    , bugStore : undefined
    
    , load : function(){
      
      var objectLoader = new THREE.ObjectLoader(manager);
      var textureLoader = new THREE.TextureLoader(manager);
      
      // floor
      var floorTexture = textureLoader.load( "assets/sand.jpg" );
      floorTexture.wrapS = THREE.RepeatWrapping;
      floorTexture.wrapT = THREE.RepeatWrapping;
      floorTexture.repeat.set(4, 4);
      var floorMat = new THREE.MeshBasicMaterial({color: 0x888888, side: THREE.DoubleSide, map:floorTexture});
      vw.gamefloor = new THREE.Mesh(new THREE.PlaneGeometry(1000, 1000, 1, 1),floorMat);
      vw.gamefloor.rotation.x = Math.PI / 2;
      scene.add(vw.gamefloor);
    
      // skybox
      var materialArray = [];
      var posfixs = ['xpos', 'xneg', 'ypos', 'yneg', 'zpos', 'zneg'];
      posfixs.forEach(function(val){
        materialArray.push(new THREE.MeshBasicMaterial({
          map:textureLoader.load('images/dawnmountain-' + val + '.png'),
          side:THREE.BackSide}));
      });
      var skyboxMaterial = new THREE.MeshFaceMaterial( materialArray );
      var skyboxGeom = new THREE.CubeGeometry( 5000, 5000, 5000, 1, 1, 1 );
      var skybox = new THREE.Mesh( skyboxGeom, skyboxMaterial );
      vw.skybox = skybox;
      scene.add( skybox );
      
      // light it up
      var ambient = new THREE.AmbientLight( 0x444444 );
	    scene.add( ambient );
	    var directionalLight = new THREE.DirectionalLight( 0xffeedd );
	    directionalLight.position.set( 1, 2, 3 ).normalize();
	    scene.add( directionalLight );
    
      // get models
      objectLoader.load("models/ant.json", function ( obj ) {
        obj.children[0].children.forEach(function(o){
          o.material.color.setHex(0x0d0d0d);
        });
        vw.ant0 = obj;
      });
      objectLoader.load("models/anthill.json", function ( obj ) {
        var earthTexture = textureLoader.load( "assets/earth.jpg" );
        var mat = new THREE.MeshPhongMaterial({color:0x663300});
        mat.map = earthTexture;
        obj.children[0].children[1].material = mat;
        obj.children[0].children[0].material.color.setHex(0x000000);
        obj.children[0].children[2].material.color.setHex(0xffffff);
        vw.hill0 = obj;
      });
      objectLoader.load("models/apple.json", function ( obj ) {
        obj.children[0].children[0].material.color.setHex(0x00cc00);
        obj.children[0].children[1].material.color.setHex(0x66aa00);
        vw.apple0 = obj;
      });
      objectLoader.load("models/bug.json", function ( obj ) {
        obj.children[0].children.forEach(function(o){
          o.material.color.setHex(0x000000);
          o.material.specular.setHex(0x00dddd);
        });
        vw.bug0 = obj;
      });
      objectLoader.load("models/sugar.json", function ( obj ) {
        obj.children[0].children[0].material.color.setHex(0xffffff);
        vw.sugar0 = obj;
      });
    }
    
    , onLoad : function(){
      // open stores
      vw.antStore = new UnitStore(vw.ant0);
      vw.hillStore = new UnitStore(vw.hill0);
      vw.appleStore = new UnitStore(vw.apple0);
      vw.bugStore = new UnitStore(vw.bug0);
      vw.sugarStore = new UnitStore(vw.sugar0);
    }
    
    , setAntBodyColor : function(ant, c){
      [/*10,*/ 7, 6].forEach(function(id){
        ant.children[0].children[id].material = new THREE.MeshPhongMaterial({color:c});
      });
    }
    
    , setHillFlagColor : function(hill, c){
      hill.children[0].children[2].material = new THREE.MeshPhongMaterial({color:c});
    }
    
    , setBugEyeColor : function(bug, color) {
      [6, 7].forEach(function(id){
        bug.children[0].children[id].material.color.setHex(color);
      });
    }
  }
  
  
  
  // START OF simulation pulsing: start, stop, interval, end
  
  var SimPulse = {
      running : false
    , nextTickTime : undefined
    , simulationFps : 15.0
    , fpsInterval : undefined
    , needsRedraw : false
    , cycles : 0
    
    , init:function(){
      // call this to start simulation
      SimPulse.needsRedraw = true;
      SimPulse.running = true;
      SimPulse.fpsInterval = 1000.0 / SimPulse.simulationFps;
      SimPulse.cycles = 0;
      Sim.init();
      SimPulse.nextTickTime = Date.now() + SimPulse.simulationFps;
      SimPulse.tick();
    }
    
    , tick:function(){
      if (SimPulse.cycles >= SimOpts.SimulationCycles) {
        end();
        return;
      }
      Sim.update();
      SimPulse.cycles++;
      SimPulse.needsRedraw = true;
      if (SimPulse.running) {
        // make sure we are really running the right fps
        var curTime = Date.now();
        var diff = SimPulse.nextTickTime - curTime;
        var interval = SimPulse.fpsInterval + diff;
        if (interval < 0) interval = 0;
        SimPulse.nextTickTime = curTime + SimPulse.fpsInterval;
        setTimeout(SimPulse.tick,interval);
      }
    }
    
    , end:function(){
      SimPulse.running = false;
    }
  }
  
  
  // TONS OF options to tune
  
  var SimOpts = {
      PlayGroundAspect : 4.0/3.0
    , PlayGroundBaseSize: 550000
    , PlayGroundSizePlayerMultiplier : 1
    , AntHillRadius : 32
    , BattleRange : 5
    , SimulationCycles : 5000
    , playerColors : [0xff0000, 0x00ff00, 0x0000ff, 0x00ffff]
    , SugarAmount : 1000
    , Sugar1Scale : 2000
    , AppleRespawnDelay : 25
    , SugarRespawnDelay : 25
    , AntRespawnDelay : 15
    , BugRespawnDelay : 15
    , BugEnergy : 1000
    , BugAttack : 50
    , BugRotationSpeed : 3
    , BugSpeed : 3
    , BugRadius : 4
    , BugRegenerationValue : 1
    , BugRegenerationDelay : 5
  }
  
  // FINALLY THE real deal ... but yet testing only
  
    // PLAYER
  function Player(id, ant){
    this.id = id;
    this.ant = ant;
  }
  
    // HILL
  function Hill(pos, playerid){
    this.pos = pos;
    this.key = playerid;
    var hill = vw.hillStore.get(this.key);
    vw.setHillFlagColor(hill, SimOpts.playerColors[playerid]);
    this.updatePos();
  }
  
  Hill.prototype.updatePos = function(){
    vw.hillStore.get(this.key).position.copy(Sim.toViewPosition(this.pos));
  }
  
    // ANT
  var antIndexCounter = 0;
  function Ant(pos, playerid){
    this.playerid = playerid
    this.pos = pos
    this.id = antIndexCounter++;
    this.key = playerid + ':' + this.id
    var ant = vw.antStore.get(this.key);
    vw.setAntBodyColor(ant, SimOpts.playerColors[this.playerid]);
    this.updatePos();
  }
  
  Ant.prototype.updatePos = function(){
    vw.antStore.get(this.key).position.copy(Sim.toViewPosition(this.pos));
  }
  
    // SUGAR
  var sugarIndexCounter = 0;
  function Sugar(pos){
    this.amount = SimOpts.SugarAmount;
    this.pos = pos;
    this.key = sugarIndexCounter++;
    this.updatePos();
    this.updateScale();
  }
  
  Sugar.prototype.updatePos = function(){
    vw.sugarStore.get(this.key).position.copy(Sim.toViewPosition(this.pos));
  }
  
  Sugar.prototype.updateScale = function(){
    var scale = this.amount / SimOpts.Sugar1Scale;
    vw.sugarStore.get(this.key).scale.set(scale, scale, scale);
  }
  
    // APPLE
  var appleIndexCounter = 0;
  function Apple(pos){
    this.pos = pos;
    this.key = appleIndexCounter++;
    this.updatePos();
  }
  
  Apple.prototype.updatePos = function(){
    vw.appleStore.get(this.key).position.copy(Sim.toViewPosition(this.pos));
  }
  
    // BUG
  var bugIndexCounter = 0;
  function Bug(pos){
    this.pos = pos;
    this.key = bugIndexCounter++;
    this.energy = SimOpts.BugEnergy;
    this.rotation = 0;
    this.distance = 0;
    this.heading = Math.round(Math.random()*360.0);
    this.attacking = false;
    this.moving = false;
    this.delay = 0;
    this.updatePos();
  }
  
  Bug.prototype.updatePos = function(){
    vw.bugStore.get(this.key).position.copy(Sim.toViewPosition(this.pos));
    vw.bugStore.get(this.key).rotation.y = -this.heading / 180 * Math.PI + Math.PI;
  }
  
  
  // here everything comes together
  
  var Sim = {
      players : []
    , playerCount : undefined
    , playgroundWidth : undefined
    , playgroundHeight : undefined  
    , nextAnt : undefined
    , nextSugar : undefined
    , nextApple : undefined
    , nextBug : undefined
    , ants : []
    , sugars : []
    , apples : []
    , hills : []
    , bugs : []
  
  
      
      
      
    
    
    , spawnAnt(playerid){
      var pos = Sim.hills[playerid].pos;
      var degree = Math.random()*Math.PI*2;
      var xc = pos.x + Math.sin(degree)*SimOpts.AntHillRadius*1.2;
      var yc = pos.y + Math.cos(degree)*SimOpts.AntHillRadius*1.2;
      Sim.ants.push(new Ant({x:xc,y:yc}, playerid));
    }
    
    , toViewPosition(pos){
      return new THREE.Vector3(pos.x-Sim.playgroundWidth/2.0, 0, pos.y-Sim.playgroundHeight/2.0);
    }
    
    , randomPos(){
      return {
        x:Math.random()*Sim.playgroundWidth,
        y:Math.random()*Sim.playgroundHeight};
    }
    
    , getHillPos:function(){
      var pos;
      var limit = 100;
      while(limit > 0) {
        pos = Sim.randomPos();
        if (pos.x < 50 || pos.y < 50)
          continue;
        if (Sim.playgroundWidth - pos.x < 50 || Sim.playgroundHeight - pos.y < 50)
          continue;
        var isGood = true;
        for(var i = 0; i < Sim.hills.length; i++) {
          var distance = Sim.getDistanceSq(Sim.hills[i].pos, pos);
          if (distance < 300*300) {
            isGood = false;
          }
        }
        if (!isGood) continue;
        return pos;
      }
      return pos;
    }
    
    , getGoodyPos:function(){
      var pos;
      var limit = 100;
      while (limit > 0) {
        pos = Sim.randomPos();
        if (!Sim.isInBound(pos,50))
          continue;
        var toNear = false;
        var atLeastNear = false;
        for(var i = 0; i < Sim.hills.length; i++) {
          var distance = Sim.getDistanceSq(Sim.hills[i].pos,pos);
          if (distance < 300*300) {
            toNear = true;
          }
          if (distance < 1500*1500) {
            atLeastNear = true;
          }
        }
        if (toNear) continue;
        if (!atLeastNear) continue;
        toNear = false;
        var checkDist = function(obj){
          var distance = Sim.getDistanceSq(obj.pos, pos);
          if (distance < 150 * 150) {
            toNear = true;
          }
        };
        Sim.apples.forEach(checkDist);
        Sim.sugars.forEach(checkDist);
        if (toNear) continue;
        return pos;
      }
      return pos;
    }
    
    , getDistanceSq:function(a,b){
      return Math.pow(a.x-b.x,2) + Math.pow(a.y-b.y,2);
    }
    
    , isInBound:function(pos, margin){
      if (margin == undefined)
        margin = 0;
      if (pos.x < margin || pos.y < margin)
          return false;
      if (Sim.playgroundWidth - pos.x < margin || Sim.playgroundHeight - pos.y < margin)
        return false;
      return true;
    }
    
    
    
    , init:function(){ //# Phase 1 (Initialisierung)
      
      //# Rahmenparameter für die Simulation wird ermittelt (Siehe Einstellunge)
      Sim.playerCount = AntMe.ants.length;
      Sim.nextAnt = SimOpts.AntRespawnDelay;
      Sim.nextSugar = SimOpts.SugarRespawnDelay;
      Sim.nextApple = SimOpts.AppleRespawnDelay;
      Sim.nextBug = SimOpts.BugRespawnDelay;
      
      //# Spielfeldgröße wird ermittelt (Abhängig von Spielerzahl)
      var area = (1 + (Sim.playerCount * SimOpts.PlayGroundSizePlayerMultiplier)) * SimOpts.PlayGroundBaseSize;
      Sim.playgroundWidth = Math.round(Math.sqrt(area * SimOpts.PlayGroundAspect));
      Sim.playgroundHeight = Math.round(Math.sqrt(area / SimOpts.PlayGroundAspect));
    
      vw.gamefloor.geometry = new THREE.PlaneGeometry(Sim.playgroundWidth, Sim.playgroundHeight, 1, 1);
      vw.gamefloor.geometry.verticesNeedUpdate = true;
    
      //# Für jeden Spieleer wird die Position des Ameisenhügels per Zufall bestimmt
      for(var i = 0; i < AntMe.ants.length; i++){
        Sim.players.push(new Player(i, AntMe.ants[i]));
        Sim.hills.push(new Hill(Sim.getHillPos(), i));
      }
      
    }
    
    , update:function(){ //# Phase 2 (Rundenberechnung)
      //# Verarbeitung der Nahrungsmittel
      
        //## Leere Zuckerhügel wegräumen: Bedingung ist hier, dass die Menge des Zuckers 0 ist
        // cool stackoverflower
        Array.prototype.removeIf = function(callback) {
            var i = this.length;
            while (i--) {
                if (callback(this[i], i)) {
                    this.splice(i, 1);
                }
            }
        };
        Sim.sugars.removeIf(function(obj){return obj.amount <= 0;});
        
        //## Neue Zuckerhügel erzeugen: Es wird geprüft, ob die Gesamtzahl der Zuckerberge groß genug ist(?) und die Respawn-Wartezeit abgewartet wurde. Wird ein neuer Berg erstellt, wird die Position per Zufall bestimmt und seine Menge wird durch den Standardwert der Einstellungen bestimmt
        if (Sim.nextSugar-- <= 0 && Sim.sugars.length < Sim.playerCount+2){
          Sim.nextSugar = SimOpts.SugarRespawnDelay;
          Sim.sugars.push(new Sugar(Sim.getGoodyPos()));
        }
        
        //## Neue Äpfel erzeugen ...
        if (Sim.nextApple-- <= 0 && Sim.apples.length < Sim.playerCount*2 + 1){
          Sim.nextApple = SimOpts.AppleRespawnDelay;
          Sim.apples.push(new Apple(Sim.getGoodyPos()));
        }
    
      //# Wanzenbewegung
      
        //## Falls eine Wanze im Kampf verwickelt: Angriffspunkte auf beteiligte Gegner verteilen. Betroffene Ameisen erhalten einen Aufruf auf WirdAngegriffen(Wanze)
        
        // TODO
        
        //## Kein Kampf: Wanzen bewegen sich zufällig auf dem Spielfeld
        Sim.bugs.forEach(function(bug){
          if (!bug.fighting) {
            if (bug.moving) {
              if (Math.abs(bug.rotation) > 0) {
                if (Math.abs(bug.rotation) < SimOpts.BugRotationSpeed) {
                  bug.heading += bug.rotation;
                  bug.rotation = 0;
                  bug.updatePos();
                } else {
                  bug.heading += SimOpts.BugRotationSpeed * Math.sign(bug.rotation);
                  bug.rotation -= SimOpts.BugRotationSpeed * Math.sign(bug.rotation);
                  bug.updatePos();
                  return;
                }
              }
              if (bug.distance > 0) {
                var toMove;
                var toret = false;
                if (bug.distance < SimOpts.BugSpeed) {
                  toMove = bug.distance;
                  bug.distance = 0;
                  bug.updatePos();
                } else {
                  bug.distance -= SimOpts.BugSpeed;
                  toMove = SimOpts.BugSpeed;
                  bug.updatePos();
                  toret = true;
                }
                var oldx = bug.pos.x;
                var oldy = bug.pos.y;
                bug.pos.x += toMove*Math.cos(bug.heading/180*Math.PI);
                bug.pos.y += toMove*Math.sin(bug.heading/180*Math.PI);
                if (!Sim.isInBound(bug.pos, 4)){
                  bug.pos.x=oldx;bug.pos.y=oldy;
                  bug.rotation = 180;
                  bug.moving = true;
                  bug.updatePos();
                  return;
                }
                bug.updatePos();
                if (toret) return;
              }
              bug.moving = false;
              bug.delay = 10;
            } else {
              if (bug.delay-- <= 0) {
                bug.moving = true;
                bug.rotation = Math.round(Math.random()*180-90);
                bug.distance = 100;
              }
            }            
          }
        });
        
    
      if (Sim.nextAnt-- <= 0) {
        Sim.nextAnt = SimOpts.AntRespawnDelay;
        for(var i = 0; i < Sim.playerCount; i++) {
          Sim.spawnAnt(i);
        }
      }
      if (Sim.nextBug-- <= 0 && Sim.bugs.length < Sim.playerCount+1) {
        Sim.nextBug = SimOpts.BugRespawnDelay;
        Sim.bugs.push(new Bug(Sim.getHillPos()));
      }
    }
  }
  
  var AntMe = {
      ants : []
    , addAnt:function(ant){
      AntMe.ants.push(ant);
    }
  }
  
  
  
  
  
  // USER SPACE
   
  AntMe.addAnt({name:"ant1"});
  AntMe.addAnt({name:"ant2"});
  AntMe.addAnt({name:"ant2"});
  AntMe.addAnt({name:"ant2"});
  
  init();
  

//})(window);
        </script>
        <div style="position: absolute; z-index: 1; left: 50px; top: 50px; width:400px; height:30px;font-size:2em;color:white">
	<p>Click/drag to rotate. Mouse wheel to zoom.</p>
</div>
    </body>
</html>
