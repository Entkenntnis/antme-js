<!DOCTYPE HTML>
<html>
    <head>
        <meta charset="utf-8">
        <title>Loading Ant model!</title>
        <style>
            body { margin: 0}
            canvas { width:100%; height:100% }
        </style>
    </head>
    <body>
        <script src="js/THREE.js"></script>
        <script src="js/orbit.js"></script>
        <script src="js/tween.js"></script>
        <script src="js/stats.min.js"></script>
        <script>
"use strict";

// encapsulate our project
//(function(global){
  
  // project-wide variables
  var scene, camera, renderer, stats, controls, manager;
  
  function init(){
    // our stage
    scene = new THREE.Scene();
    
    // the floor lies in the xz-plane, don't worry about aspect here, will be done on resize 
    camera = new THREE.PerspectiveCamera(60, 1 /*aspect*/, 0.1, 10000);
    camera.position.set(0, 600, 1700);
    
    // the worker in the shadow
    renderer = new THREE.WebGLRenderer();
    document.body.appendChild(renderer.domElement);
    
    // showing nice fps
    stats = new Stats();
    stats.showPanel( 1 ); // 0: fps, 1: ms, 2: mb, 3+: custom
    document.body.appendChild( stats.dom );
    
    // make it movable
    controls = new THREE.OrbitControls(camera);
    controls.maxPolarAngle = Math.PI/2;
    controls.maxDistance = 2000;
    controls.clamper = function(pos){
      if (pos.y < 0.5) {pos.y = 0.5;} // should add clamper to protect skybox
    };
    
    // handle loading
    manager = new THREE.LoadingManager();
    
    // making it awesome fullwindow
    window.addEventListener('resize', resize, false);
    resize();
    
    vw.load();
    
    manager.onLoad = function(){
      vw.onLoad();
      SimPulse.init(); // currently simulation starts automatically
      animate()
    };
  }
  
  function resize() {
    var w = document.documentElement.clientWidth;
    var h = document.documentElement.clientHeight;
    renderer.setSize(w, h);
    camera.aspect = w/h;
    camera.updateProjectionMatrix();
  }

  function animate(e){
    if (SimPulse.needsRedraw){
      stats.begin();
      renderer.render(scene, camera);
      SimPulse.needRedraw = false;
      stats.end();
    }
    requestAnimationFrame(animate);
  }
  
  
  // THIS IS a 3d object manager
  function UnitStore(proto){
    var store = {};
    var ready = [];
    var prefix = 'unitstorekey:';
    
    this.has = function(id){
      return (prefix + id) in store;
    }
    this.get = function(id){
      if (this.has(id))
        return store[prefix + id];
      else {
        if (ready.length > 0) {
          var next = ready[0];
          next.visible = true;
          ready.splice(0, 1);
          store[prefix + id] = next;
          return next;
        } else {
          var newUnit = proto.clone();
          scene.add(newUnit);
          store[prefix+id] = newUnit;
          return newUnit;
        }
      }
    }
    this.remove = function(id){
      var obj = store[prefix + id];
      obj.visible = false;
      delete store[prefix + id];
      ready.push(obj);
    }
  }
  
  
  
  // START OF 3d view related stuff
  
  var vw = {
      ant0 : undefined
    , bug0 : undefined
    , hill0 : undefined
    , sugar0 : undefined
    , apple0 : undefined
    , gamefloor : undefined
    , skybox : undefined
    , antStore : undefined
    , hillStore : undefined
    , sugarStore : undefined
    , appleStore : undefined
    , bugStore : undefined
    
    , load : function(){
      
      var objectLoader = new THREE.ObjectLoader(manager);
      var textureLoader = new THREE.TextureLoader(manager);
      
      // floor
      var floorTexture = textureLoader.load( "assets/sand.jpg" );
      floorTexture.wrapS = THREE.RepeatWrapping;
      floorTexture.wrapT = THREE.RepeatWrapping;
      floorTexture.repeat.set(4, 4);
      var floorMat = new THREE.MeshBasicMaterial({color: 0x888888, side: THREE.DoubleSide, map:floorTexture});
      vw.gamefloor = new THREE.Mesh(new THREE.PlaneGeometry(1000, 1000, 1, 1),floorMat);
      vw.gamefloor.rotation.x = Math.PI / 2;
      scene.add(vw.gamefloor);
    
      // skybox
      var materialArray = [];
      var posfixs = ['xpos', 'xneg', 'ypos', 'yneg', 'zpos', 'zneg'];
      posfixs.forEach(function(val){
        materialArray.push(new THREE.MeshBasicMaterial({
          map:textureLoader.load('images/dawnmountain-' + val + '.png'),
          side:THREE.BackSide}));
      });
      var skyboxMaterial = new THREE.MeshFaceMaterial( materialArray );
      var skyboxGeom = new THREE.CubeGeometry( 5000, 5000, 5000, 1, 1, 1 );
      var skybox = new THREE.Mesh( skyboxGeom, skyboxMaterial );
      vw.skybox = skybox;
      scene.add( skybox );
      
      // light it up
      var ambient = new THREE.AmbientLight( 0x444444 );
	    scene.add( ambient );
	    var directionalLight = new THREE.DirectionalLight( 0xffeedd );
	    directionalLight.position.set( 1, 2, 3 ).normalize();
	    scene.add( directionalLight );
    
      // get models
      objectLoader.load("models/ant.json", function ( obj ) {
        obj.children[0].children.forEach(function(o){
          o.material.color.setHex(0x0d0d0d);
        });
        vw.ant0 = obj;
      });
      objectLoader.load("models/anthill.json", function ( obj ) {
        var earthTexture = textureLoader.load( "assets/earth.jpg" );
        var mat = new THREE.MeshPhongMaterial({color:0x663300});
        mat.map = earthTexture;
        obj.children[0].children[1].material = mat;
        obj.children[0].children[0].material.color.setHex(0x000000);
        obj.children[0].children[2].material.color.setHex(0xffffff);
        vw.hill0 = obj;
      });
      objectLoader.load("models/apple.json", function ( obj ) {
        obj.children[0].children[0].material.color.setHex(0x00cc00);
        obj.children[0].children[1].material.color.setHex(0x669900);
        vw.apple0 = obj;
      });
      objectLoader.load("models/bug.json", function ( obj ) {
        obj.children[0].children.forEach(function(o){
          o.material.color.setHex(0x000000);
          o.material.specular.setHex(0x00dddd);
        });
        vw.bug0 = obj;
      });
      objectLoader.load("models/sugar.json", function ( obj ) {
        obj.children[0].children[0].material.color.setHex(0xffffff);
        vw.sugar0 = obj;
      });
    }
    
    , onLoad : function(){
      // open stores
      vw.antStore = new UnitStore(vw.ant0);
      vw.hillStore = new UnitStore(vw.hill0);
      vw.appleStore = new UnitStore(vw.apple0);
      vw.bugStore = new UnitStore(vw.bug0);
      vw.sugarStore = new UnitStore(vw.sugar0);
    }
    
    , setAntBodyColor : function(ant, c){
      [/*10,*/ 7, 6].forEach(function(id){
        ant.children[0].children[id].material = new THREE.MeshPhongMaterial({color:c});
      });
    }
    
    , setHillFlagColor : function(hill, c){
      hill.children[0].children[2].material = new THREE.MeshPhongMaterial({color:c});
    }
    
    , setBugEyeColor : function(bug, color) {
      [6, 7].forEach(function(id){
        bug.children[0].children[id].material.color.setHex(color);
      });
    }
  }
  
  
  
  // START OF simulation pulsing: start, stop, interval, end
  
  var SimPulse = {
      running : false
    , nextTickTime : undefined
    , simulationFps : 15.0
    , fpsInterval : undefined
    , needsRedraw : false
    , cycles : 0
    
    , init:function(){
      // call this to start simulation
      SimPulse.needsRedraw = true;
      SimPulse.running = true;
      SimPulse.fpsInterval = 1000.0 / SimPulse.simulationFps;
      SimPulse.cycles = 0;
      Sim.init();
      SimPulse.nextTickTime = Date.now() + SimPulse.simulationFps;
      SimPulse.tick();
    }
    
    , tick:function(){
      if (SimPulse.cycles >= SimOpts.SimulationCycles) {
        end();
        return;
      }
      Sim.update();
      SimPulse.cycles++;
      SimPulse.needsRedraw = true;
      if (SimPulse.running) {
        // make sure we are really running the right fps
        var curTime = Date.now();
        var diff = SimPulse.nextTickTime - curTime;
        var interval = SimPulse.fpsInterval + diff;
        if (interval < 0) interval = 0;
        SimPulse.nextTickTime = curTime + SimPulse.fpsInterval;
        setTimeout(SimPulse.tick,interval);
      }
    }
    
    , end:function(){
      SimPulse.running = false;
    }
  }
  
  
  // TONS OF options to tune
  
  var SimOpts = {
      PlayGroundAspect : 4.0/3.0
    , PlayGroundBaseSize: 550000
    , PlayGroundSizePlayerMultiplier : 1
    , AntHillRadius : 32
    , BattleRange : 5
    , SimulationCycles : 5000
    , playerColors : [0xff0000, 0x00ff00, 0x0000ff, 0x00ffff]
    , SugarAmount : 1000
    , Sugar1Scale : 2000
  }
  
  // FINALLY THE real deal ... but yet testing only
  
    // PLAYER
  function Player(id, ant){
    this.id = id;
    this.ant = ant;
  }
  
    // HILL
  function Hill(pos, playerid){
    this.pos = pos;
    this.key = playerid;
    var hill = vw.hillStore.get(this.key);
    vw.setHillFlagColor(hill, SimOpts.playerColors[playerid]);
    
    this.updatePos();
  }
  
  Hill.prototype.updatePos = function(){
    vw.hillStore.get(this.key).position.copy(Sim.toViewPosition(this.pos));
  }
  
    // ANT
  var antIndexCounter = 0;
  function Ant(pos, playerid){
    this.playerid = playerid
    this.pos = pos
    this.id = antIndexCounter++;
    this.key = playerid + ':' + this.id
    var ant = vw.antStore.get(this.key);
    vw.setAntBodyColor(ant, SimOpts.playerColors[this.playerid]);
    this.updatePos();
  }
  
  Ant.prototype.updatePos = function(){
    vw.antStore.get(this.key).position.copy(Sim.toViewPosition(this.pos));
  }
  
    // SUGAR
  var sugarIndexCounter = 0;
  function Sugar(pos){
    this.amount = SimOpts.SugarAmount;
    this.pos = pos;
    this.key = sugarIndexCounter++;
    this.updatePos();
    this.updateScale();
  }
  
  Sugar.prototype.updatePos = function(){
    vw.sugarStore.get(this.key).position.copy(Sim.toViewPosition(this.pos));
  }
  
  Sugar.prototype.updateScale = function(){
    var scale = this.amount / SimOpts.Sugar1Scale;
    vw.sugarStore.get(this.key).scale.set(scale, scale, scale);
  }
  
    // APPLE
  var appleIndexCounter = 0;
  function Apple(pos){
    this.pos = pos;
    this.key = appleIndexCounter++;
    this.updatePos();
  }
  
  Apple.prototype.updatePos = function(){
    vw.appleStore.get(this.key).position.copy(Sim.toViewPosition(this.pos));
  }
  
    // BUG
  var bugIndexCounter = 0;
  function Bug(pos){
    this.pos = pos;
    this.key = bugIndexCounter++;
    this.updatePos();
  }
  
  Bug.prototype.updatePos = function(){
    vw.bugStore.get(this.key).position.copy(Sim.toViewPosition(this.pos));
  }
  
  
  // here everything comes together
  
  var Sim = {
      players : []
    , playerCount : undefined
    , playgroundWidth : undefined
    , playgroundHeight : undefined  
    , nextAnt : undefined
    , nextSugar : undefined
    , nextApple : undefined
    , nextBug : undefined
    , ants : []
    , sugars : []
    , apples : []
    , hills : []
  
  
      
      
      
    , init:function(){ // called once when simulation starts
      
      Sim.playerCount = AntMe.ants.length;
      
      var area = (1 + (Sim.playerCount * SimOpts.PlayGroundSizePlayerMultiplier)) * SimOpts.PlayGroundBaseSize;
      Sim.playgroundWidth = Math.round(Math.sqrt(area * SimOpts.PlayGroundAspect));
      Sim.playgroundHeight = Math.round(Math.sqrt(area / SimOpts.PlayGroundAspect));
    
      vw.gamefloor.geometry = new THREE.PlaneGeometry(Sim.playgroundWidth, Sim.playgroundHeight, 1, 1);
      vw.gamefloor.geometry.verticesNeedUpdate = true;
    
      for(var i = 0; i < AntMe.ants.length; i++){
        Sim.players.push(new Player(i, AntMe.ants[i]));
        Sim.hills.push(new Hill(Sim.getHillPos(), i));
      }
      
      Sim.nextAnt = 15;
      Sim.nextSugar = 50;
      Sim.nextApple = 75;
      
      
    }
    
    , spawnAnt(playerid){
      Sim.ants.push(new Ant(/*{x:hills[playerid].x+THREE.Math.randFloatSpread(60.0),y:hills[playerid].y+THREE.Math.randFloatSpread(60.0)}*/Sim.randomPos(), playerid));
    }
    
    , toViewPosition(pos){
      return new THREE.Vector3(pos.x-Sim.playgroundWidth/2.0, 0, pos.y-Sim.playgroundHeight/2.0);
    }
    
    , randomPos(){
      return {
        x:Math.random()*Sim.playgroundWidth,
        y:Math.random()*Sim.playgroundHeight};
    }
    
    , getHillPos:function(){
      var pos;
      var limit = 100;
      while(limit > 0) {
        pos = Sim.randomPos();
        if (pos.x < 50 || pos.y < 50)
          continue;
        if (Sim.playgroundWidth - pos.x < 50 || Sim.playgroundHeight - pos.y < 50)
          continue;
        var isGood = true;
        for(var i = 0; i < Sim.hills.length; i++) {
          var distance = Math.pow(Sim.hills[i].pos.x-pos.x, 2) + Math.pow(Sim.hills[i].pos.y-pos.y, 2);
          if (distance < 300*300) {
            isGood = false;
          }
        }
        if (!isGood) continue;
        return pos;
      }
      return pos;
    }
    
    , update:function(){ // called for every round
      if (Sim.nextAnt-- <= 0) {
        Sim.nextAnt = 15;
        for(var i = 0; i < Sim.playerCount; i++) {
          Sim.spawnAnt(i);
        }
      }
      if (Sim.nextSugar-- <= 0 && Sim.sugars.length < 4){
        Sim.nextSugar = 50;
        Sim.sugars.push(new Sugar(Sim.randomPos()));
      }
      if (Sim.nextApple-- <= 0 && Sim.apples.length < 6){
        Sim.nextApple = 75;
        Sim.apples.push(new Apple(Sim.randomPos()));
      }
    
    }
  }
  
  var AntMe = {
      ants : []
    , addAnt:function(ant){
      AntMe.ants.push(ant);
    }
  }
  
  
  
  
  
  // USER SPACE
   
  AntMe.addAnt({name:"ant1"});
  AntMe.addAnt({name:"ant2"});
  AntMe.addAnt({name:"ant2"});
  AntMe.addAnt({name:"ant2"});
  
  init();
  

//})(window);
        </script>
        <div style="position: absolute; z-index: 1; left: 50px; top: 50px; width:400px; height:30px;font-size:2em;color:white">
	<p>Click/drag to rotate. Mouse wheel to zoom.</p>
</div>
    </body>
</html>
